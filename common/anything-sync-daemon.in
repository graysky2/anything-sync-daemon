#!/usr/bin/env bash

#
# Anything-sync-daemon by graysky <graysky AT archlinux DOT us>
# Inspired by some code originally written by Colin Verot
#

readonly PS4='+ ${BASH_SOURCE:-${0}}@${LINENO:-0}${FUNCNAME:+#${FUNCNAME}()}: '

diag() {
  echo "$@" >&2
}

ediag() {
  diag -e "$@"
}

# For debug, add DEBUG=1 asd
if [[ "${DEBUG:-}" = 1 ]]; then
  debug() {
    ediag "$@"
  }
else
  debug() {
    :
  }
fi

verbosely() {
  if (( "$#" < 1 )); then
    ediag "${RED}INTERNAL ERROR:${NRM} Usage: ${FUNCNAME[0]} <command> [<arg> ...]"
    return 1
  fi

  debug "${ON_START:-"running command '$*'"}"

  local rc=0
  "$@" || {
    rc="$?"
    debug "${ON_ERROR:-"command '$*' exited with status '$rc'"}"
    return "$rc"
  }

  debug "${ON_SUCCESS:-"command '$*' succeeded"}"

  return 0
}

set -euo pipefail

# shellcheck disable=SC2317
diag_error() {
  diag "Error occurred at ${1:-unknown line}"
}

trap 'diag_error "$LINENO"' ERR

have_dep() {
  command -v "${1?}" &>/dev/null
}

have_dep_diag() {
  have_dep "${1?}" || {
    local rc="$?"
    diag "I require ${1?} but it's not installed. Aborting."
    return "$rc"
  }
}

if [[ "${FLOCKER:-}" != "$0" ]]; then
  debug "checking flock"
  have_dep_diag flock || exit
  debug "flock found"
fi

debug_vars() {
  local var
  for var in "$@"; do
    if [[ -v "$var" ]]; then
      debug "${var}: ${!var}"
    else
      debug "${var}: <unset>"
    fi
  done
}

running_as_root() {
  local euid="${EUID:-$(id -u)}" || return
  (( euid == 0 ))
}

looks_like_systemd_system() {
  systemctl --system list-unit-files asd.service &>/dev/null \
    || [[ -f /usr/lib/systemd/system/asd.service ]]
}

looks_like_systemd_user() {
  systemctl --user list-unit-files asd.service &>/dev/null \
    || [[ -f /usr/lib/systemd/user/asd.service ]]
}

is_truthy() {
  local b="${1?}"
  case "${b,,}" in
    y|yes|true|t|on|1|enabled|enable|use)
      return 0
      ;;
    *)
      return 1
      ;;
  esac
}

serialize_conf_vars() {
  declare -p \
    BACKUP_LIMIT  \
    DEBUG \
    ENABLE_HARDLINK_SAFETY_CHECK \
    USE_BACKUPS \
    USE_OVERLAYFS \
    VOLATILE \
    WHATTOSYNC 2>/dev/null || :
}

serialize_conf_vars_with_timeout() {
  export -f serialize_conf_vars

  # shellcheck disable=SC2016
  timeout "${ASDCONFTIMEOUT:-10}" "$BASH" "-$-" -c '
    source "${1?}" || exit
    serialize_conf_vars
  ' "$0" "${1?}"
}

use_v1_paths() {
  running_as_root && ! is_truthy "${ASDNOV1PATHS:-}"
}

if running_as_root; then
  looks_like_systemd() {
    looks_like_systemd_system
  }

  systemctl_show() {
    systemctl --system "$@"
  }

  if looks_like_systemd; then
    ASDCONFDIR="${ASDCONFDIR:-"${CONFIGURATION_DIRECTORY:-/etc/asd}"}"
    ASDRUNDIR="${ASDRUNDIR:-"${RUNTIME_DIRECTORY:-/run/asd}"}"
  else
    ASDCONFDIR="${ASDCONFDIR:-/etc/asd}"
    ASDRUNDIR="${ASDRUNDIR:-/run/asd}"
  fi
else
  looks_like_systemd() {
    looks_like_systemd_user
  }

  systemctl_show() {
    systemctl --user "$@"
  }

  if looks_like_systemd; then
    ASDCONFDIR="${ASDCONFDIR:-"${CONFIGURATION_DIRECTORY:-${XDG_CONFIG_HOME:-${HOME?}/.config}/asd}"}"
    ASDRUNDIR="${ASDRUNDIR:-"${RUNTIME_DIRECTORY:-${XDG_RUNTIME_DIR:-/run/user/${EUID:-$(id -u)}}/asd}"}"
  else
    ASDCONFDIR="${ASDCONFDIR:-"${XDG_CONFIG_HOME:-${HOME?}/.config}/asd"}"
    ASDRUNDIR="${ASDRUNDIR:-"${XDG_RUNTIME_DIR:-/run/user/${EUID:-$(id -u)}}/asd"}"
  fi
fi

if [[ -n "${NO_COLOR:-}" ]]; then
  BLD=''
  RED=''
  GRN=''
  BLU=''
  NRM=''
else
  BLD="\e[01m"
  RED="\e[01;31m"
  GRN="\e[01;32m"
  BLU="\e[01;34m"
  NRM="\e[00m"
fi

readonly BLD RED GRN NRM

readonly VERS='@VERSION@'

readonly CRASH_RECOVERY_SUFFIX=crashrecovery
readonly ASDCONFTIMEOUT="${ASDCONFTIMEOUT:-10}"

ASDNAME=asd

umask 027

if use_v1_paths; then
  ASDCONF="${ASDCONF:-/etc/asd.conf}"
  DAEMON_FILE="${DAEMON_FILE:-/run/asd}"

  if [[ "$ASDCONF" != /etc/asd.conf ]]; then
    suffix="$(realpath "$ASDCONF" | sha256sum | cut -b -16)"
    ASDNAME="${ASDNAME}-${suffix}"
    if [[ "$DAEMON_FILE" == /run/asd ]]; then
      DAEMON_FILE="/run/${ASDNAME}"
    fi
  fi

  LOCKFILE="/run/${ASDNAME}-lock"
else
  ASDCONF="${ASDCONF:-${ASDCONFDIR}/asd.conf}"
  DAEMON_FILE="${DAEMON_FILE:-${ASDRUNDIR}/asd.run}"
  LOCKFILE="${ASDRUNDIR}/asd.lock"

  mkdir -p "$ASDRUNDIR"
fi

readonly ASDCONFDIR ASDNAME ASDRUNDIR DAEMON_FILE LOCKFILE

readonly ASDCONF_SOURCE="$ASDCONF"
readonly ASDCONF_SNAPSHOT="${DAEMON_FILE}.conf"

mkdir -p "$(dirname "$DAEMON_FILE")"

# shellcheck disable=SC2015
if [[ "${FLOCKER:-}" != "$0" ]]; then
  ediag "${RED}Waiting for lock...${NRM}"
  FLOCKER="$0" exec flock -x "$LOCKFILE" "$BASH" "-$-" "$0" "$@"
fi

debug "${RED}ASDNAME:${NRM} ${ASDNAME}"
debug "${BLU}Configuration file:${NRM} ${ASDCONF_SOURCE}"
debug "${GRN}Daemon file:${NRM} ${DAEMON_FILE}"
debug "${RED}Lockfile:${NRM} ${LOCKFILE}\n"

# Setup check /etc/asd.conf
debug "Checking for existence of ${ASDCONF_SOURCE}"
if [[ -f "$ASDCONF_SOURCE" ]]; then
  debug "Checking if asd is already running"

  if [[ -f "$DAEMON_FILE" ]]; then
    debug "Daemon file found; asd is running"
  else
    debug "Daemon file not found; asd is not running"
  fi
else
  ediag " ${BLD}Cannot find ${ASDCONF_SOURCE} so bailing.${NRM}"
  ediag " ${BLD}Reinstall package to use anything-sync-daemon.${NRM}"
  exit 1
fi

# if asd is active, source the snapshot of /etc/asd.conf preferentially
if [[ -f "$ASDCONF_SNAPSHOT" ]]; then
  debug "\nRestoring old asd.conf configurations"
else
  # make a snapshot of the current configuration on the tmpfs while asd is
  # running to keep any edits made to the live `ASDCONF` from potentially
  # orphaning the tmpfs copies thus preserving the data
  mkdir -p "$(dirname "$ASDCONF_SNAPSHOT")"
  ON_START="creating configuration snapshot at ${ASDCONF_SNAPSHOT}" \
    verbosely serialize_conf_vars_with_timeout "$ASDCONF_SOURCE" > "$ASDCONF_SNAPSHOT" || {
      rc="$?"
      ediag -n "${BLD}Error creating configuration snapshot ${ASDCONF_SNAPSHOT} from configuration file ${ASDCONF_SOURCE}"
      case "$rc" in
        # Probably timed out.  124 is coreutils, 143 is busybox.
        124|143)
          diag -n " (sourcing ${ASDCONF_SNAPSHOT} appears to have timed out)"
          ;;
      esac
      ediag "; cannot continue.${NRM}"
      rm -f "$ASDCONF_SNAPSHOT"
      exit "$rc"
    }
fi

readonly ASDCONF="$ASDCONF_SNAPSHOT"

# shellcheck source=./asd.conf source-path=SCRIPTDIR
source "$ASDCONF" || {
  rc="$?"
  ediag "${BLD}Error sourcing ${ASDCONF}; cannot continue.${NRM}"
  rm -f "$ASDCONF_SNAPSHOT"
  exit "$rc"
}

debug # just for an additional enter

# define default number of crash-recovery snapshots to save if the user did not
# and check that it is an integer if user did define it
if ! [[ "${BACKUP_LIMIT:=5}" =~ ^[[:digit:]]+$ ]]; then
  ediag " ${RED}ERROR:${NRM}${BLD} Bad value for BACKUP_LIMIT detected!${NRM}"
  exit 1
fi
debug "Backup limit: ${BACKUP_LIMIT}"

# saving current extended pattern matching setting
# command returns non zero exit code if the option is unset hence
# pipe with `:`
previous_extglob_setting="$(shopt -p extglob || :)"

# ensuring pattern matching is enabled
shopt -s extglob

# removing any trailing slash(es) from the list of directories to sync
# explicitly declare the variable in case it was unset in `ASDCONF`.
declare -a WHATTOSYNC
WHATTOSYNC=("${WHATTOSYNC[@]%%+(/)}")

if [[ -z "${VOLATILE:-}" ]]; then
  if use_v1_paths; then
    VOLATILE=/tmp
  else
    VOLATILE="$ASDRUNDIR"
  fi
fi

# removing any trailing slash(es) from the volatile directory
VOLATILE="${VOLATILE%%+(/)}"

# setting everything back
$previous_extglob_setting || :
unset previous_extglob_setting

debug "Volatile dir: ${VOLATILE}"

looks_like_tmpfs_or_zram() {
  df -T "${1?}" | grep -q '\( tmpfs \|^/dev/zram\)'
}

looks_like_tmpfs_or_zram_diag() {
  looks_like_tmpfs_or_zram "${1?}" || {
    local rc="$?"
    diag "${1?} is not tmpfs/zram so running asd is pointless. Aborting."
    return "$rc"
  }
}

# bail if $VOLATILE isn't tmpfs
looks_like_tmpfs_or_zram_diag "$VOLATILE"

debug "Hardlink safety check: ${ENABLE_HARDLINK_SAFETY_CHECK:=1}"

# simple function to determine user intent rather than using a null value
if is_truthy "${USE_OVERLAYFS:-}"; then
  OLFS=1
else
  OLFS=0
fi

# since the default for this one is a yes, need to force a null value to yes
debug "Backups enabled: ${USE_BACKUPS:=yes}"

if is_truthy "$USE_BACKUPS"; then
  CRRE=1
else
  CRRE=0
fi

debug "Crash recovery enabled: $CRRE"

# determine is we are using overlayfs (v22 and below) or overlay (v23 and above)
# overlay FS v23 and later requires both an upper and a work directory, both on
# the same filesystem, but not part of the same subtree.
#
# ubuntu 15.04 has both overlay and overlayfs so prefer version 23
if [[ "$OLFS" = 1 ]]; then
  # first test if either module is manually loaded manually or hardcoded
  if grep -qiE "overlay$" /proc/filesystems 2>/dev/null; then
    OLFSVER=23
  elif grep -qiE "overlayfs$" /proc/filesystems 2>/dev/null; then
    OLFSVER=22
  # since mount should call modprobe on invocation, check to see if either
  # module is in the tree using modinfo
  elif modinfo overlay &>/dev/null; then
    OLFSVER=23
  elif modinfo overlayfs &>/dev/null; then
    OLFSVER=22
  else
    diag "overlayfs is not supported by your system, falling back to normal."
    OLFS=0
  fi
fi

debug "overlayfs enabled: $OLFS"
debug "overlayfs version: ${OLFSVER:-unknown}"

# get distro name
# first try os-release
if [[ -f /etc/os-release ]]; then
  # shellcheck source=/dev/null
  source /etc/os-release 2>/dev/null || :
  distro="${PRETTY_NAME:-${NAME}}"
fi

# if not os-release try issue
distro="${distro:-$(sed -n '/./ { s| \\.*$||; p; q }' /etc/issue 2>/dev/null)}" || :

if [[ -z "$distro" ]]; then
  header() {
    ediag "${BLD}Anything-sync-daemon v${VERS}${NRM}"
    diag
  }
else
  header() {
    ediag "${BLD}Anything-sync-daemon v${VERS}${NRM}${BLD} on ${distro}${NRM}"
    diag
  }
fi

# For bind mounts, and for overlay mounts when `USE_OVERLAYFS` is in effect.
need_sudo_to_mount() {
  ! running_as_root
}

# Need `sudo` even when running as root in order to check directory ownership
# in `asd-mount-helper`.
need_sudo() {
  [[ "${OLFS:-}" = 1 ]] || need_sudo_to_mount
}

if need_sudo_to_mount; then
  run_mount_helper() {
    sudo asd-mount-helper "$@"
  }
else
  run_mount_helper() {
    asd-mount-helper "$@"
  }
fi

find_mount() {
  findmnt --noheadings --notruncate "$@"
}

bind_mount_fsroot() {
  local with_fsroot without_fsroot

  with_fsroot="$(find_mount -o SOURCE -M "${1?}")" || return
  without_fsroot="$(find_mount --nofsroot -o SOURCE -M "${1?}")" || return

  # Not a bind mount
  [[ "$with_fsroot" != "$without_fsroot" ]] || return

  local fsroot="${with_fsroot#"${without_fsroot}["}"
  printf -- '%s\n' "${fsroot%]}"
}

mount_is_overlay() {
  local fstype
  fstype="$(find_mount -o FSTYPE -M "${1?}")" || return

  case "$fstype" in
    overlay | overlayfs )
      return 0
      ;;
    *)
      return 1
      ;;
  esac
}

mount_options_match() {
  local src="$1"
  shift

  local tgt="$1"
  shift

  local src_options tgt_options
  src_options="$(find_mount -o FS-OPTIONS -m "$src")" || return
  tgt_options="$(find_mount -o FS-OPTIONS -m "$tgt")" || return

  [[ "$src_options" == "$tgt_options" ]]
}

bind_mount_has_expected_source() {
  local src="$1"
  shift

  local tgt="$1"
  shift

  local fsroot
  fsroot="$(bind_mount_fsroot "$tgt")" && [[ "$fsroot" == "$src" ]]
}

sync_target_is_mounted() {
  local src="$1"
  shift

  local tgt="$1"
  shift

  if bind_mount_has_expected_source "$src" "$tgt"; then
    return 0
  fi

  # Don't bother checking whether overlays are mounted if we're not using
  # overlays.
  [[ "${OLFS:-}" = 1 ]] || return

  mount_is_overlay "$tgt" || return

  ! mount_is_overlay "$src" || mount_options_match "$src" "$tgt"
}

# Call a provided command for each entry in `WHATTOSYNC`, setting certain
# variables for use within the command.
for_each_dir() {
  if (( "$#" < 1 )); then
    ediag "${RED}INTERNAL ERROR:${NRM} Usage: ${FUNCNAME[0]} <command> [<arg> ...]"
    return 1
  fi

  local DIR BACKUP BACK_OLD

  # Variables defined in this loop are expected to be used by the callback
  # command.  We don't need to export them, and it's not a problem if they
  # aren't used in the loop body.
  # shellcheck disable=SC2034
  for DIR in "${WHATTOSYNC[@]}"; do
    # did user define a real dir
    # this is the hdd bound backup in case of power failure
    if [[ ${DIR##*/} == .* ]]; then
      BACKUP="${DIR}-backup_asd"
    else
      BACKUP="${DIR%/*}/.${DIR##*/}-backup_asd"
    fi

    BACK_OLD="${BACKUP}-old"

    if [[ -d "$DIR" ]]; then
      local DIR_USER DIR_GROUP
      DIR_USER="$(stat -c %U "$DIR" 2>/dev/null)" || :
      DIR_GROUP="$(id -gn "$DIR_USER" 2>/dev/null)" || :

      local DIR_TMP="${VOLATILE}/${ASDNAME}-${DIR_USER}${DIR}"
      local DIR_UPPER="${VOLATILE}/${ASDNAME}-${DIR_USER}${DIR}-rw"
      local DIR_WORK="${VOLATILE}/.${ASDNAME}-${DIR_USER}${DIR}"

      local USER="$DIR_USER"
      local GROUP="$DIR_GROUP"
      local TMP="$DIR_TMP"
      local UPPER="$DIR_UPPER"
      local WORK="$DIR_WORK"
    fi

    if [[ -d "$BACKUP" ]]; then
      local BACK_USER BACK_GROUP
      BACK_USER="$(stat -c %U "$BACKUP" 2>/dev/null)" || :
      BACK_GROUP="$(id -gn "$BACK_USER" 2>/dev/null)" || :

      local BACK_TMP="${VOLATILE}/${ASDNAME}-${BACK_USER}${DIR}"
      local BACK_UPPER="${VOLATILE}/${ASDNAME}-${BACK_USER}${DIR}-rw"
      local BACK_WORK="${VOLATILE}/.${ASDNAME}-${BACK_USER}${DIR}"

      local USER="${USER:-${BACK_USER}}"
      local GROUP="${GROUP:-${BACK_GROUP}}"
      local TMP="${TMP:-${BACK_TMP}}"
      local UPPER="${UPPER:-${BACK_UPPER}}"
      local WORK="${WORK:-${BACK_WORK}}"
    fi

    # Don't construct this unless the caller requested it; there are
    # potentially many backups and there's no need to slow down code that
    # won't use this by iterating over a bunch of directory entries.
    if is_truthy "${NEED_CRASHArr:-}"; then
      local -a CRASHArr=()
      local crashed
      for crashed in "${BACKUP}-${CRASH_RECOVERY_SUFFIX}-"*.tar.zstd; do
        if [[ -e "$crashed" ]]; then
          CRASHArr+=("$crashed")
        fi
      done
      unset crashed
    fi

    "$@" || return
  done
}

dep_check() {
  # Function is used to ensure all dependencies are installed
  debug "\n${BLU}Checking dependencies${NRM}"

  local -a deps=(
    rsync awk pv tar zstd
  )

  if need_sudo; then
    deps+=(sudo)
  fi

  local dep
  local rc=0
  for dep in "${deps[@]}"; do
    debug "checking ${dep}"
    have_dep_diag "$dep" || rc="$?"
  done

  if [[ "${OLFS:-}" = 1 ]] && { [[ -z "$OLFSVER" ]] || (( OLFSVER < 22 )) ; }; then
    ediag " ${BLD}Your kernel requires either the ${BLU}overlay${NRM}${BLD} or ${BLU}overlayfs${NRM}${BLD} module to use${NRM}"
    ediag " ${BLD}to use asd's in overlay mode. Cannot find either in your kernel so compile it in and${NRM}"
    ediag " ${BLD}try again or remove the option from ${BLU}${ASDCONF}${NRM}${BLD}. ${RED}Aborting!${NRM}"
    rc=1
  fi

  return "$rc"
}

config_check() {
  debug "\n${GRN}Checking configs${NRM}"

  local rc=0

  # nothing to do if these are empty
  if (( "${#WHATTOSYNC[@]}" < 1 )); then
    ediag " ${BLD}Must define at least one directory in ${NRM}${BLU}${ASDCONF}${NRM}"
    rc=1
  fi

  local sudo_error
  if [[ "${OLFS:-}" = 1 ]] && need_sudo_to_mount && ! sudo_error="$(sudo -kn asd-mount-helper 2>&1)"; then
    ediag " ${RED} ERROR!${NRM}${BLD} To use overlayfs mode, your user needs passwordless sudo access to ${BLU}asd-mount-helper${NRM}."
    ediag " ${BLD} Error was: ${sudo_error}${NRM}"
    rc=1
  fi

  # make sure the user defined real dirs
  _config_check() {
    debug_vars DIR BACKUP BACK_OLD

    if ! [[ -d "$DIR" ]]; then
      if ! [[ -d "$BACK_OLD" ]]; then
        ediag "${BLD}Bad entry in your WHATTOSYNC array detected:${NRM}"
        ediag " ${BLD}${RED}${DIR}${NRM}"
        ediag "${BLD}Edit ${BLU}${ASDCONF}${NRM}${BLD} correcting the mistake and try again.${NRM}"
        return 1
      fi
    else
      # sanity check for hardlinks
      if ! [[ -d "$BACK_OLD" ]] && [[ "$ENABLE_HARDLINK_SAFETY_CHECK" != 0 ]]; then
        local first_link
        if first_link="$(find "$DIR" -type f -links +1 -print -quit)" && [[ -n "$first_link" ]]; then
          ediag "${DIR}:\n${RED} Presence of hardlinks found, asd might break them:${NRM}"
          return 1
        else
          debug "No hardlinks found"
        fi
      fi
    fi
  }

  for_each_dir _config_check || rc="$?"

  if (( rc == 0 )); then
    debug "Configs seem to be fine"
  else
    debug "Removing ${ASDCONF_SNAPSHOT}"
    rm -f "$ASDCONF_SNAPSHOT"
  fi

  return "$rc"
}

ungraceful_state_check() {
  # if the machine was ungracefully shutdown then the backup will be
  # on the filesystem and the link to tmpfs will be on the filesystem
  # but the contents will be empty we need to simply remove the link
  # and rotate the backup into place
  debug "\n${BLU}checking ungraceful state${NRM}"

  _ungraceful_state_check() {
    if [[ -d "${BACKUP?}" ]]; then
      USER="${BACK_USER?}"
      GROUP="${BACK_GROUP?}"
      TMP="${BACK_TMP?}"
      UPPER="${BACK_UPPER?}"
      WORK="${BACK_WORK?}"
    fi

    debug_vars DIR BACKUP BACK_OLD USER TMP

    local dir_is_mounted=0 backup_is_mounted=0 tmp_is_mounted=0

    if [[ -d "$BACKUP" ]] && bind_mount_has_expected_source "$DIR" "$BACKUP"; then
      debug "Backup directory ${BACKUP} is currently mounted"
      backup_is_mounted=1
    else
      debug "Backup directory ${BACKUP} is currently unmounted"
    fi

    if [[ -v TMP ]]; then
      if [[ -d "$DIR" ]] && sync_target_is_mounted "$TMP" "$DIR"; then
        debug "Sync target ${DIR} is currently mounted"
        dir_is_mounted=1
      else
        debug "Sync target ${DIR} is currently unmounted"
      fi

      if [[ -d "$TMP" ]] && { [[ "$OLFS" = 0 ]] || mount_is_overlay "$TMP"; }; then
        debug "Temporary directory ${TMP} is currently present"
        tmp_is_mounted=1
      else
        debug "Temporary directory ${TMP} is currently absent"
      fi
    fi

    if [[ "$dir_is_mounted" != "$backup_is_mounted" ]] || [[ "$backup_is_mounted" != "$tmp_is_mounted" ]]; then
      debug "Inconsistent mount state detected for sync target ${DIR}"
    elif [[ "$tmp_is_mounted" = 1 ]]; then
      if [[ -e "${TMP}/.flagged" ]]; then
        return
      fi

      debug "Temporary directory ${TMP} for sync target ${DIR} is not flagged"
    else
      return 0
    fi

    diag "Ungraceful state detected for ${DIR?} so fixing"

    local rc=0

    local NOW
    NOW="$(date +%Y%m%d_%H%M%S 2>/dev/null)" || :

    if [[ "${dir_is_mounted:-}" = 1 ]]; then
      ON_START="unmounting ${DIR}" verbosely run_mount_helper -d "$DIR" mountdownall || rc="$?"
    fi

    if [[ "${backup_is_mounted:-}" = 1 ]]; then
      if ON_START="unmounting ${BACKUP}" verbosely run_mount_helper -d "$BACKUP" mountdownall; then
        rm -rf "$BACKUP"
        debug "removed ${BACKUP} dir"
      else
        rc="$?"
      fi
    fi

    if [[ "$OLFS" = 1 ]] && [[ "${tmp_is_mounted:-}" = 1 ]]; then
      if ON_START="unmounting overlay dirs" verbosely run_mount_helper -v "$OLFSVER" -l "$BACKUP" -u "$UPPER" -w "$WORK" -d "$TMP" mountdown; then
        rm -rf "$TMP" "$UPPER" "$WORK"
        debug "unmounted overlay dirs"
      else
        rc="$?"
      fi
    fi

    if [[ -d "${BACK_OLD?}" ]]; then
      if [[ "$CRRE" = 1 ]]; then
        local BACK_NEW="${BACKUP}-${CRASH_RECOVERY_SUFFIX}-${NOW}.tar.zstd"
        debug "copying ${BACK_OLD} to ${BACK_NEW}"
        tar cf - -C "${BACK_OLD%/*}" "${BACK_OLD##*/}" | pv -s "$(du -sb "$BACK_OLD" | awk '{print $1}')" | zstd > "$BACK_NEW" || rc="$?"
      fi

      rm -rf "$BACK_OLD"
      debug "deleted the ${BACK_OLD} directory"
    fi

    if [[ -v TMP ]] && (( rc == 0 )); then
      rm -f "${TMP?}/.flagged"
    fi

    return "$rc"
  }

  for_each_dir _ungraceful_state_check
}

cleanup() {
  debug "\n${BLU}Cleaning up crashrecoveries${NRM}"

  _cleanup() {
    debug_vars DIR USER GROUP TMP UPPER WORK

    if (( "${#CRASHArr[@]}" > 0 )); then
      ediag "${BLD}Deleting ${#CRASHArr[*]} crashrecovery dir(s) for sync target ${BLU}${DIR?}${NRM}"
      local backup
      for backup in "${CRASHArr[@]}"; do
        ediag "${BLD}${RED} ${backup}${NRM}"
        debug "removing ${backup}"
        rm -rf "$backup"
      done
    else
      ediag "${BLD}Found no crashrecovery dirs for: ${BLU}${DIR?}${NRM}${BLD}${NRM}"
    fi

    diag
  }

  NEED_CRASHArr=1 for_each_dir _cleanup
}

enforce() {
  debug "\n${BLU}Enforcing number of backups${NRM}"

  _enforce() {
    debug_vars DIR BACKUP

    if (( "${#CRASHArr[@]}" > BACKUP_LIMIT )); then
      debug "The backups are greater than ${BACKUP_LIMIT}"
      local remove
      for remove in "${CRASHArr[@]:$BACKUP_LIMIT}"; do
        debug "removing ${remove}"
        rm -rf "$remove"
      done
    else
      debug "The backups are less than ${BACKUP_LIMIT}, nothing to do"
    fi
  }

  NEED_CRASHArr=1 for_each_dir _enforce
}

do_sync() {
  debug "\n${GRN}Syncing files${NRM}"

  # sync to tmpfs and back again
  _do_sync() {
    debug_vars DIR USER GROUP BACKUP TMP UPPER WORK

    # make tmpfs container
    if [[ -d "$DIR" ]]; then
      # retain permissions on sync target
      PREFIXP="$(stat -c %a "$DIR" 2>/dev/null)" || :
      PREFIXP="${PREFIXP:-0750}"

      if ! [[ -r "$TMP" ]]; then
        verbosely install -dm"$PREFIXP" --owner="${USER?}" --group="${GROUP?}" "$TMP" || return
      fi

      if ! [[ -r "$BACKUP" ]]; then
        verbosely install -dm"$PREFIXP" --owner="$USER" --group="$GROUP" "$BACKUP" || return
      fi

      if [[ "$OLFS" = 1 ]]; then
        debug "ensuring overlay directories"

        if ! [[ -r "$UPPER" ]]; then
          verbosely install -dm"$PREFIXP" --owner="$USER" --group="$GROUP" "$UPPER" || return
        fi

        if [[ "$OLFSVER" = 23 ]]; then
          if ! [[ -r "$WORK" ]]; then
            verbosely install -dm"$PREFIXP" --owner="$USER" --group="$GROUP" "$WORK" || return
          fi
        fi
      fi

      # sync the tmpfs targets to the disc
      if [[ -e "$TMP"/.flagged ]]; then
        debug "Syncing ${TMP} and ${BACKUP}"
        # don't do inplace sync
        set -x
        rsync -aX --delete-after --exclude .flagged "$TMP/" "$BACKUP/" --info=progress2 || return
        set +x
      else
        # backup target and link to tmpfs container
        ON_START="Bind mounting ${DIR} -> ${BACKUP}" verbosely run_mount_helper -s "$DIR" -d "$BACKUP" mountupbind || return

        if [[ "$CRRE" = 1 ]];then
          debug "Creating new linked backup directory ${BACK_OLD}"
          tempfile=$(mktemp)

          set -x
          # this copies all the files
          find "$BACKUP" -type l -printf '%P\n' > "$tempfile"
          rm -rf "$BACK_OLD"
          rsync -aX --no-links --link-dest="$DIR" "$DIR/" "$BACK_OLD/" --info=progress2 || return

          # this is used to handle the symlinks
          rsync -aXl --files-from="$tempfile" "$DIR/" "$BACK_OLD/" --info=progress2 || return

          set +x
          rm "$tempfile"
        fi

        # initial sync
        if [[ "$OLFS" = 1 ]]; then
          ON_START="Mounting overlay directory" verbosely run_mount_helper -v "$OLFSVER" -l "$BACKUP" -u "$UPPER" -w "$WORK" -d "$TMP" mountup || return
        else
          debug "Doing initial sync with ${BACKUP} and ${TMP}"
          set -x
          rsync -aXl --append "${BACKUP}/" "${TMP}/" --info=progress2 || return
          set +x
        fi

        ON_START="bind mounting ${TMP} -> ${DIR}" verbosely run_mount_helper -s "$TMP" -d "$DIR" mountupbind || return

        touch "${TMP}/.flagged" || return
      fi
    fi
  }

  for_each_dir _do_sync || {
    local rc="$?"
    ediag "${RED}Sync failed${NRM}"
    return "$rc"
  }

  ediag "${BLD}Sync successful${NRM}"

  ON_START="creating ${DAEMON_FILE}" verbosely touch "$DAEMON_FILE"
}

do_unsync() {
  debug "\n${RED}Unsyncing files${NRM}"

  _do_unsync() {
    debug_vars DIR USER GROUP TMP UPPER WORK

    # remove link and move data from tmpfs to disk
    if mountpoint -q "$DIR"; then
      # this assumes that the backup is always
      # updated so be sure to invoke a sync before an unsync
      ON_START="unmounting ${DIR}" verbosely run_mount_helper -d "$DIR" mountdownallforce || return

      ON_START="unmounting ${BACKUP}" verbosely run_mount_helper -d "$BACKUP" mountdownallforce || return

      debug "removing ${BACKUP}"
      rm -rf "$BACKUP"

      if [[ "$OLFS" = 1 ]]; then
        if mountpoint -q "$TMP"; then
          ON_START="unmounting $TMP" verbosely run_mount_helper -d "$TMP" mountdownlazy || return

          debug "removing overlayfs folders"
          rm -rf "$TMP" "$UPPER" "$WORK"
        fi
      elif [[ -d "$TMP" ]]; then
        debug "removing $TMP"
        rm -rf "$TMP"
      fi

      if [[ "$CRRE" = 1 ]]; then
        debug "removing $BACK_OLD"
        rm -rf "$BACK_OLD"
      fi
    fi
  }

  local rc=0
  for_each_dir _do_unsync || rc="$?"

  if (( rc == 0 )); then
    ediag "${BLD}Unsync successful${NRM}"
  else
    ediag "${RED}Unsync failed${NRM}"
  fi

  # delete daemon file in the end, so that unsync can be run again
  # incase of some failure midway
  # since unsync also requires sync before, if any of the DIRS are unsynced during last run,
  # they will be synced again before unsyncing not leading to any breakage

  debug "Removing ${DAEMON_FILE} and ${ASDCONF_SNAPSHOT}"
  rm -f "$DAEMON_FILE" "$ASDCONF_SNAPSHOT"

  return "$rc"
}

parse() {
  if looks_like_systemd; then
    # running systemd
    asd_state="$(systemctl_show -p ActiveState --value asd 2>/dev/null)" || :
    resync_state="$(systemctl_show -p ActiveState --value asd-resync.timer 2>/dev/null)" || :

    if [[ "$asd_state" = "active" ]]; then
      asd_color="$GRN"
    else
      asd_color="$RED"
    fi

    if [[ "$resync_state" = "active" ]]; then
      resync_color="$GRN"
    else
      resync_color="$RED"
    fi

    ediag " ${BLD}Systemd service is currently ${asd_color}${asd_state}${NRM}${BLD}.${NRM}"
    ediag " ${BLD}Systemd resync service is currently ${resync_color}${resync_state}${NRM}${BLD}.${NRM}"
  else
    # using other init system + cron job for resync
    if [[ -x /etc/cron.hourly/asd-update ]]; then
      resync_state="present"
      resync_color="$GRN"
    else
      resync_state="not present"
      resync_color="$RED"
    fi

    ediag -n " ${BLD}Daemon pid file is "
    if [[ -f $DAEMON_FILE ]]; then
      ediag "${GRN}present${NRM}${BLD}.${NRM}"
    else
      ediag "${RED}not present${NRM}${BLD}.${NRM}"
    fi

    ediag " ${BLD}Resync cronjob is ${resync_color}${resync_state}${NRM}${BLD}.${NRM}"
  fi

  if [[ "$OLFS" = 1 ]]; then
    ediag "${BLD} OverlayFS v${OLFSVER} is currently ${GRN}active${NRM}${BLD}.${NRM}"
  else
    ediag "${BLD} OverlayFS technology is currently ${RED}inactive${NRM}${BLD}.${NRM}"
  fi

  diag
  ediag "${BLD}Anything-sync-daemon will manage the following per ${BLU}${ASDCONF}${NRM}${BLD} settings:${NRM}"
  diag

  _parse() {
    # sync target dir size
    if [[ -d "$DIR" ]]; then
      local justify
      justify="$(tput cr)$(tput cuf 20) "
      ediag " ${BLD}owner/group id:${justify}${USER}/${GROUP}${NRM}"
      ediag " ${BLD}target to manage:${justify}${GRN}${DIR}${NRM}"
      ediag " ${BLD}sync target:${justify}${BLU}${BACKUP}${NRM}"
      ediag " ${BLD}tmpfs target:${justify}${RED}${TMP}${NRM}"
      psize="$(du -Dh --max-depth=0 "$DIR" 2>/dev/null | awk '{ print $1 }')" || :
      ediag " ${BLD}dir size:${justify}${psize:-unknown}${NRM}"

      if [[ "$OLFS" = 1 ]]; then
        rwsize=$(du -Dh --max-depth=0 "$UPPER" 2>/dev/null | awk '{ print $1 }')
        ediag " ${BLD}overlayfs size:${justify}${rwsize}${NRM}"
      fi

      ediag -n " ${BLD}recovery dirs:"

      if (( "${#CRASHArr[@]}" ==  0 )); then
        ediag "${justify}none${NRM}"
      else
        ediag "${justify}${RED}${#CRASHArr[@]}${NRM}${BLD} <- delete with the c option${NRM}"
        for backup in "${CRASHArr[@]}"; do
          psize=$(du -Dh --max-depth=0 "$backup" 2>/dev/null | awk '{ print $1 }')
          ediag " ${BLD} dir path/size:${justify}${BLU}${backup} ${NRM}${BLD}(${psize})${NRM}"
        done
      fi

      diag
    fi
  }

  NEED_CRASHArr=1 for_each_dir _parse
}

main() {
  case "${1:-}" in
    p|P|Parse|parse|Preview|preview|debug)
      header
      dep_check
      config_check
      parse
      ;;
    c|C|clean|Clean)
      header
      dep_check
      config_check
      cleanup
      ;;
    sync)
      if ! [[ -f "$DAEMON_FILE" ]]; then
        dep_check
        config_check
        ungraceful_state_check
        do_sync
        enforce
      else
        ediag "${GRN}ASD is already running${NRM}"
      fi
      ;;
    resync)
      if [[ -f "$DAEMON_FILE" ]]; then
        ungraceful_state_check
        do_sync
      else
        ediag "${RED}ASD is not running${NRM}"
      fi
      ;;
    unsync)
      # make sure the daemon ran to setup the links
      if [[ -f "$DAEMON_FILE" ]]; then
        ungraceful_state_check
        do_sync
        do_unsync
      else
        ediag "${RED}ASD is not running${NRM}"
      fi
      ;;
    *)
      echo -e "${BLD}Anything-sync-daemon v${VERS}${NRM}"
      echo
      echo -e " ${BLD}${0} ${NRM}${GRN}[option]${NRM}"
      echo -e " ${BLD} ${NRM}${GRN}preview${NRM}${BLD}  Parse config file (${NRM}${BLU}${ASDCONF}${NRM}${BLD}) to see what will be managed.${NRM}"
      echo -e " ${BLD} ${NRM}${GRN}clean${NRM}${BLD}		Clean (delete without prompting) ALL crashrecovery dirs.${NRM}"
      echo -e " ${BLD} ${NRM}${GRN}resync${NRM}${BLD} Synchronize the tmpfs and media bound copy. Must be run as root user.${NRM}"
      echo -e " ${BLD} ${NRM}${RED}sync${NRM}${BLD}   Force a manual sync. NOT recommended.${NRM}"
      echo -e " ${BLD} ${NRM}${RED}unsync${NRM}${BLD} Force a manual unsync. NOT recommended.${NRM}"
      echo
      echo -e " ${BLD}It is ${RED}HIGHLY DISCOURAGED${NRM}${BLD} to directly call ${0} to sync or to unsync.${NRM}"
      if looks_like_systemd; then
        echo -e " ${BLD}Instead, use systemd to start/stop anything-sync-daemon.${NRM}"
        echo
        echo -e " ${BLD}systemctl ${NRM}${GRN}[option]${NRM}${BLD} asd asd-resync${NRM}"
        echo -e " ${BLD} ${NRM}${GRN}start${NRM}${BLD}    Turn on daemon; make symlinks and actively manage targets in tmpfs.${NRM}"
        echo -e " ${BLD} ${NRM}${GRN}stop${NRM}${BLD}   Turn off daemon; remove symlinks and rotate tmpfs data back to disc.${NRM}"
        echo -e " ${BLD} ${NRM}${GRN}enable${NRM}${BLD} Autostart daemon when system comes up.${NRM}"
        echo -e " ${BLD} ${NRM}${GRN}disable${NRM}${BLD}  Remove daemon from the list of autostart daemons.${NRM}"
      elif [[ -f /etc/init.d/asd ]]; then
        echo -e " ${BLD}Instead, use the init system to start/stop anything-sync-daemon.${NRM}"
        echo
        echo -e " ${BLD}sudo service asd ${NRM}${GRN}[option]${NRM}${BLD} or /etc/init.d/asd ${NRM}${GRN}[option]${NRM}"
        echo -e " ${BLD} ${NRM}${GRN}start${NRM}${BLD}  Turn on daemon; make symlinks and actively manage targets in tmpfs.${NRM}"
        echo -e " ${BLD} ${NRM}${GRN}stop${NRM}${BLD} Turn off daemon; remove symlinks and rotate tmpfs data back to disc.${NRM}"
      fi
      ;;
  esac
}

main "$@"

# vim:set ts=2 sw=2 et:
