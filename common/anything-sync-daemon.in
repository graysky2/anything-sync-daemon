#!/usr/bin/env bash

#
# Anything-sync-daemon by graysky <graysky AT archlinux DOT us>
# Inspired by some code originally written by Colin Verot
#

diag() {
  echo "$@" >&2
}

ediag() {
  diag -e "$@"
}

croak() {
  local rc="$?"
  ediag "${RED}ERROR:${NRM} $*"
  return "$rc"
}

verbosely() {
  if (( "$#" < 1 )); then
    ediag "${RED}INTERNAL ERROR:${NRM} Usage: ${FUNCNAME[0]} <command> [<arg> ...]"
    return 1
  fi

  debug "${ON_START:-"running command '$*'"}"

  local rc=0
  "$@" || {
    rc="$?"
    debug "${ON_ERROR:-"command '$*' exited with status '$rc'"}"
    return "$rc"
  }

  debug "${ON_SUCCESS:-"command '$*' succeeded"}"

  return 0
}

# shellcheck disable=SC2317
diag_error() {
  diag "Error occurred at ${1:-unknown line}"
}

have_dep() {
  command -v "${1?}" &>/dev/null
}

have_dep_diag() {
  have_dep "${1?}" || {
    local rc="$?"
    diag "I require ${1?} but it's not installed. Aborting."
    return "$rc"
  }
}

debug_vars() {
  local var
  for var in "$@"; do
    if [[ -v "$var" ]]; then
      debug "${var}: ${!var}"
    else
      debug "${var}: <unset>"
    fi
  done
}

running_as_root() {
  local euid="${EUID:-$(id -u)}" || return
  (( euid == 0 ))
}

run_systemctl_system() {
  systemctl --system "$@"
}

run_systemctl_user() {
  systemctl --user "$@"
}

systemd_unit_name() {
  [[ -v INVOCATION_ID ]] || return

  local id invocation_id
  while read -r prop; do
    case "$prop" in
      InvocationID=*)
        invocation_id="${prop#InvocationID=}"
        ;;
      Id=*)
        id="${prop#Id=}"
        ;;
      *)
        if [[ -v id ]] && [[ -v invocation_id ]] && [[ "$invocation_id" == "$INVOCATION_ID" ]]; then
          printf -- '%s' "$id"
          return
        else
          unset id invocation_id
        fi
        ;;
    esac
  done < <(run_systemctl show -p 'Id,InvocationID' '*')

  return 1
}

looks_like_systemd_system() {
  systemd_unit_name &>/dev/null \
    || run_systemctl_system list-unit-files asd.service &>/dev/null \
    || [[ -f /usr/lib/systemd/system/asd.service ]]
}

looks_like_systemd_user() {
  systemd_unit_name &>/dev/null \
    || run_systemctl_user list-unit-files asd.service &>/dev/null \
    || [[ -f /usr/lib/systemd/user/asd.service ]]
}

is_truthy() {
  local b="${1?}"
  case "${b,,}" in
    y|yes|true|t|on|1|enabled|enable|use)
      return 0
      ;;
    *)
      return 1
      ;;
  esac
}

serialize_conf_vars() {
  # These variables are meant to be declared in `asd.conf`, and we gracefully
  # handle them being unset.
  # shellcheck disable=SC2153
  declare -p \
    BACKUP_LIMIT  \
    DEBUG \
    ENABLE_HARDLINK_SAFETY_CHECK \
    USE_BACKUPS \
    USE_OVERLAYFS \
    VOLATILE \
    WHATTOSYNC 2>/dev/null || :
}

serialize_conf_vars_with_timeout() {
  export -f serialize_conf_vars

  # shellcheck disable=SC2016
  timeout "${ASDCONFTIMEOUT:-10}" "$BASH" "-$-" -c '
    source "${1?}" || exit
    serialize_conf_vars
  ' "$0" "${1?}"
}

use_v1_paths() {
  running_as_root && ! is_truthy "${ASDNOV1PATHS:-}"
}

looks_like_tmpfs_or_zram() {
  df -T "${1?}" | grep -q '\( tmpfs \|^/dev/zram\)'
}

looks_like_tmpfs_or_zram_diag() {
  looks_like_tmpfs_or_zram "${1?}" || {
    local rc="$?"
    diag "${1?} is not tmpfs/zram so running asd is pointless. Aborting."
    return "$rc"
  }
}

# For bind mounts, and for overlay mounts when `USE_OVERLAYFS` is in effect.
need_sudo_to_mount() {
  ! running_as_root
}

# Need `sudo` even when running as root in order to check directory ownership
# in `asd-mount-helper`.
need_sudo() {
  use_overlayfs || need_sudo_to_mount
}

find_mount() {
  verbosely findmnt --noheadings --notruncate "$@"
}

bind_mount_fsroot() {
  local with_fsroot without_fsroot

  with_fsroot="$(ON_START="finding bind mount with filesystem root for ${1?}" find_mount -o SOURCE -M "${1?}")" || return
  without_fsroot="$(ON_START="finding bind mount without filesystem root for ${1?}" find_mount --nofsroot -o SOURCE -M "${1?}")" || return

  # Not a bind mount
  [[ "$with_fsroot" != "$without_fsroot" ]] || {
    # shellcheck disable=SC2319
    local rc="$?"
    debug "${1?} does not appear to be a bind mount"
    return "$rc"
  }

  local fsroot="${with_fsroot#"${without_fsroot}["}"

  debug "found filesystem root ${fsroot} for bind mount ${1?}"

  printf -- '%s\n' "${fsroot%]}"
}

mount_is_overlay() {
  local fstype
  fstype="$(ON_START="finding filesystem type for ${1?}" find_mount -o FSTYPE -M "${1?}")" || return

  case "$fstype" in
    overlay | overlayfs )
      debug "${1?} appears to be an overlay filesystem"
      return 0
      ;;
    *)
      debug "${1?} does not appear to be an overlay filesystem"
      return 1
      ;;
  esac
}

mount_options_match() {
  local src="$1"
  shift

  local tgt="$1"
  shift

  local src_options tgt_options
  src_options="$(ON_START="determining filesystem options for source ${src}" find_mount -o FS-OPTIONS -m "$src")" || return
  tgt_options="$(ON_START="determining filesystem options for target ${tgt}" find_mount -o FS-OPTIONS -m "$tgt")" || return

  if [[ "$src_options" == "$tgt_options" ]]; then
    diag "mount options for source ${src} match those of target ${tgt}"
    return 0
  else
    diag "mount options for source ${src} do not match those of target ${tgt}"
    return 1
  fi
}

bind_mount_has_expected_source() {
  local src="$1"
  shift

  local tgt="$1"
  shift

  local fsroot
  if fsroot="$(bind_mount_fsroot "$tgt")" && [[ "$fsroot" == "$src" ]]; then
    debug "source ${src} appears to be bind-mounted at target ${tgt}"
    return 0
  else
    debug "source ${src} does not appear to be bind-mounted at target ${tgt}"
    return 1
  fi
}

sync_target_is_mounted() {
  local src="$1"
  shift

  local tgt="$1"
  shift

  if bind_mount_has_expected_source "$src" "$tgt"; then
    return 0
  fi

  # Don't bother checking whether overlays are mounted if we're not using
  # overlays.
  if ! use_overlayfs; then
    debug "not using OverlayFS; assuming target ${tgt} is not mounted"
    return 1
  fi

  mount_is_overlay "$tgt" || {
    local rc="$?"
    debug "target ${tgt} is not an overlay filesystem; assuming target ${tgt} is not mounted"
    return "$rc"
  }

  if ! mount_is_overlay "$src"; then
    debug "source ${src} is not an overlay filesystem; assuming target ${tgt} is mounted"
    return 0
  elif mount_options_match "$src" "$tgt"; then
    return 0
  else
    debug "target ${tgt} does not appear to be mounted"
    return 1
  fi
}

# Call a provided command for each entry in `WHATTOSYNC`, setting certain
# variables for use within the command.
for_each_dir() {
  if (( "$#" < 1 )); then
    ediag "${RED}INTERNAL ERROR:${NRM} Usage: ${FUNCNAME[0]} <command> [<arg> ...]"
    return 1
  fi

  local DIR BACKUP BACK_OLD

  # Variables defined in this loop are expected to be used by the callback
  # command.  We don't need to export them, and it's not a problem if they
  # aren't used in the loop body.
  # shellcheck disable=SC2034
  for DIR in "${!WHATTOSYNC_MAP[@]}"; do
    # did user define a real dir
    # this is the hdd bound backup in case of power failure
    if [[ ${DIR##*/} == .* ]]; then
      BACKUP="${DIR}-backup_asd"
    else
      BACKUP="${DIR%/*}/.${DIR##*/}-backup_asd"
    fi

    BACK_OLD="${BACKUP}-old"

    if [[ -d "$DIR" ]]; then
      local DIR_USER DIR_GROUP
      DIR_USER="$(stat -c %U "$DIR" 2>/dev/null)" || :
      DIR_GROUP="$(id -gn "$DIR_USER" 2>/dev/null)" || :

      local DIR_TMP="${VOLATILE_FINAL}/${ASDNAME}-${DIR_USER}${DIR}"
      local DIR_UPPER="${VOLATILE_FINAL}/${ASDNAME}-${DIR_USER}${DIR}-rw"
      local DIR_WORK="${VOLATILE_FINAL}/.${ASDNAME}-${DIR_USER}${DIR}"

      local USER="$DIR_USER"
      local GROUP="$DIR_GROUP"
      local TMP="$DIR_TMP"
      local UPPER="$DIR_UPPER"
      local WORK="$DIR_WORK"
    fi

    if [[ -d "$BACKUP" ]]; then
      local BACK_USER BACK_GROUP
      BACK_USER="$(stat -c %U "$BACKUP" 2>/dev/null)" || :
      BACK_GROUP="$(id -gn "$BACK_USER" 2>/dev/null)" || :

      local BACK_TMP="${VOLATILE_FINAL}/${ASDNAME}-${BACK_USER}${DIR}"
      local BACK_UPPER="${VOLATILE_FINAL}/${ASDNAME}-${BACK_USER}${DIR}-rw"
      local BACK_WORK="${VOLATILE_FINAL}/.${ASDNAME}-${BACK_USER}${DIR}"

      local USER="${USER:-${BACK_USER}}"
      local GROUP="${GROUP:-${BACK_GROUP}}"
      local TMP="${TMP:-${BACK_TMP}}"
      local UPPER="${UPPER:-${BACK_UPPER}}"
      local WORK="${WORK:-${BACK_WORK}}"
    fi

    # Don't construct this unless the caller requested it; there are
    # potentially many backups and there's no need to slow down code that
    # won't use this by iterating over a bunch of directory entries.
    if is_truthy "${NEED_CRASHArr:-}"; then
      local -a CRASHArr=()
      local crashed
      for crashed in "${BACKUP}-${CRASH_RECOVERY_SUFFIX}-"*.tar.zstd; do
        if [[ -e "$crashed" ]]; then
          CRASHArr+=("$crashed")
        fi
      done
      unset crashed
    fi

    "$@" || return
  done
}

for_each_dir_with_crasharr() {
  NEED_CRASHArr=1 for_each_dir "$@"
}

dep_check() {
  # Function is used to ensure all dependencies are installed
  debug "\n${BLU}Checking dependencies${NRM}"

  local -a deps=(
    rsync awk pv tar zstd
  )

  if need_sudo; then
    deps+=(sudo)
  fi

  local dep
  local rc=0
  for dep in "${deps[@]}"; do
    debug "checking ${dep}"
    have_dep_diag "$dep" || rc="$?"
  done

  if use_overlayfs && { [[ -z "$OVERLAYFS_VERS" ]] || (( OVERLAYFS_VERS < 22 )) ; }; then
    ediag " ${BLD}Your kernel requires either the ${BLU}overlay${NRM}${BLD} or ${BLU}overlayfs${NRM}${BLD} module to use${NRM}"
    ediag " ${BLD}to use asd's in overlay mode. Cannot find either in your kernel so compile it in and${NRM}"
    ediag " ${BLD}try again or remove the option from ${BLU}${ASDCONF}${NRM}${BLD}. ${RED}Aborting!${NRM}"
    rc=1
  fi

  return "$rc"
}

config_check() {
  debug "\n${GRN}Checking configs${NRM}"

  local rc=0

  # nothing to do if these are empty
  if ! declare -p WHATTOSYNC_MAP &>/dev/null || (( "${#WHATTOSYNC_MAP[@]}" < 1 )); then
    ediag " ${BLD}Must define at least one directory in ${NRM}${BLU}${ASDCONF}${NRM}"
    rc=1
  else
    local whattosync_entry
    local -i whattosync_entry_count
    for whattosync_entry in "${!WHATTOSYNC_MAP[@]}"; do
      whattosync_entry_count="${WHATTOSYNC_MAP["$whattosync_entry"]}"
      if (( whattosync_entry_count > 1 )); then
        ediag " ${YLW}WARNING:${NRM} sync target ${BLD}${whattosync_entry}${NRM} specified more than once"
      fi
    done
  fi

  local sudo_error
  if use_overlayfs && need_sudo_to_mount && ! sudo_error="$(sudo -kn asd-mount-helper 2>&1)"; then
    ediag " ${RED} ERROR!${NRM}${BLD} To use overlayfs mode, your user needs passwordless sudo access to ${BLU}asd-mount-helper${NRM}."
    ediag " ${BLD} Error was: ${sudo_error}${NRM}"
    rc=1
  fi

  # make sure the user defined real dirs
  _config_check() {
    debug_vars DIR BACKUP BACK_OLD

    if ! [[ -d "$DIR" ]]; then
      if ! [[ -d "$BACK_OLD" ]]; then
        ediag "${BLD}Bad entry in your WHATTOSYNC array detected:${NRM}"
        ediag " ${BLD}${RED}${DIR}${NRM}"
        ediag "${BLD}Edit ${BLU}${ASDCONF}${NRM}${BLD} correcting the mistake and try again.${NRM}"
        return 1
      fi
    else
      # sanity check for hardlinks
      if ! [[ -d "$BACK_OLD" ]] && enable_hardlink_safety_check; then
        local first_link
        if first_link="$(find "$DIR" -type f -links +1 -print -quit)" && [[ -n "$first_link" ]]; then
          ediag "${DIR}:\n${RED} Presence of hardlinks found, asd might break them:${NRM}"
          return 1
        else
          debug "No hardlinks found"
        fi
      fi
    fi
  }

  for_each_dir _config_check || rc="$?"

  if (( rc == 0 )); then
    debug "Configs seem to be fine"
  else
    debug "Removing ${ASDCONF_SNAPSHOT}"
    rm -f "$ASDCONF_SNAPSHOT"
  fi

  return "$rc"
}

ungraceful_state_check() {
  # if the machine was ungracefully shutdown then the backup will be
  # on the filesystem and the link to tmpfs will be on the filesystem
  # but the contents will be empty we need to simply remove the link
  # and rotate the backup into place
  debug "\n${BLU}checking ungraceful state${NRM}"

  _ungraceful_state_check() {
    if [[ -d "${BACKUP?}" ]]; then
      USER="${BACK_USER?}"
      GROUP="${BACK_GROUP?}"
      TMP="${BACK_TMP?}"
      UPPER="${BACK_UPPER?}"
      WORK="${BACK_WORK?}"
    fi

    debug_vars DIR BACKUP BACK_OLD USER TMP

    local dir_is_mounted=0 backup_is_mounted=0 tmp_is_mounted=0

    if [[ -d "$BACKUP" ]] && bind_mount_has_expected_source "$DIR" "$BACKUP"; then
      debug "Backup directory ${BACKUP} is currently mounted"
      backup_is_mounted=1
    elif mountpoint -q "$BACKUP"; then
      ediag "${YLW}WARNING:${NRM} backup directory ${BACKUP} is a mountpoint, but does not appear to be a bind-mount of sync target ${DIR}; this may be a bug in ${ASDNAME}"
    else
      debug "Backup directory ${BACKUP} is currently unmounted"
    fi

    if [[ -v TMP ]]; then
      if [[ -d "$DIR" ]] && sync_target_is_mounted "$TMP" "$DIR"; then
        debug "Sync target ${DIR} is currently mounted"
        dir_is_mounted=1
      elif mountpoint -q "$DIR"; then
        ediag "${YLW}WARNING:${NRM} sync target ${DIR} is a mountpoint, but does not appear to be a bind-mount of temporary directory ${TMP}; this may be a bug in ${ASDNAME}"
      else
        debug "Sync target ${DIR} is currently unmounted"
      fi

      if [[ -d "$TMP" ]]; then
        if use_overlayfs; then
          if mount_is_overlay "$TMP"; then
            debug "Temporary directory ${TMP} is currently mounted"
            tmp_is_mounted=1
          elif mountpoint -q "$TMP"; then
            ediag "${YLW}WARNING:${NRM} temporary directory ${TMP} is a mountpoint, but does not appear to be an overlay filesystem; this may be a bug in ${ASDNAME}"
          else
            debug "Temporary directory ${TMP} is currently unmounted"
          fi
        else
          debug "Temporary directory ${TMP} is currently present"
          tmp_is_mounted=1
        fi
      else
        debug "Temporary directory ${TMP} is currently absent"
      fi
    fi

    if [[ "$dir_is_mounted" != "$backup_is_mounted" ]] || [[ "$backup_is_mounted" != "$tmp_is_mounted" ]]; then
      debug "Inconsistent mount state detected for sync target ${DIR}"
    elif [[ "$tmp_is_mounted" = 1 ]]; then
      if [[ -e "${TMP}/.flagged" ]]; then
        return
      fi

      debug "Temporary directory ${TMP} for sync target ${DIR} is not flagged"
    else
      return 0
    fi

    diag "Ungraceful state detected for ${DIR?} so fixing"

    local rc=0

    local NOW
    printf -v NOW '%(%Y%m%d_%H%M%S)T' 2>/dev/null || :
    NOW="${NOW:-"$(date +%Y%m%d_%H%M%S 2>/dev/null)"}" || :

    if [[ "${dir_is_mounted:-}" = 1 ]]; then
      ON_START="unmounting ${DIR}" verbosely run_mount_helper -d "$DIR" mountdownall || rc="$?"
    fi

    if [[ "${backup_is_mounted:-}" = 1 ]]; then
      if ON_START="unmounting ${BACKUP}" verbosely run_mount_helper -d "$BACKUP" mountdownall; then
        rm -rf "$BACKUP"
        debug "removed ${BACKUP} dir"
      else
        rc="$?"
      fi
    fi

    if use_overlayfs && [[ "${tmp_is_mounted:-}" = 1 ]]; then
      if ON_START="unmounting overlay dirs" verbosely run_mount_helper -v "$OVERLAYFS_VERS" -l "$BACKUP" -u "$UPPER" -w "$WORK" -d "$TMP" mountdown; then
        rm -rf "$TMP" "$UPPER" "$WORK"
        debug "unmounted overlay dirs"
      else
        rc="$?"
      fi
    fi

    if [[ -d "${BACK_OLD?}" ]]; then
      if use_backups; then
        local BACK_NEW="${BACKUP}-${CRASH_RECOVERY_SUFFIX}-${NOW}.tar.zstd"
        debug "copying ${BACK_OLD} to ${BACK_NEW}"
        tar cf - -C "${BACK_OLD%/*}" "${BACK_OLD##*/}" | pv -s "$(du -sb "$BACK_OLD" | awk '{print $1}')" | zstd > "$BACK_NEW" || rc="$?"
      fi

      rm -rf "$BACK_OLD"
      debug "deleted the ${BACK_OLD} directory"
    fi

    if [[ -v TMP ]] && (( rc == 0 )); then
      rm -f "${TMP?}/.flagged"
    fi

    return "$rc"
  }

  for_each_dir _ungraceful_state_check
}

cleanup() {
  debug "\n${BLU}Cleaning up crashrecoveries${NRM}"

  _cleanup() {
    debug_vars DIR USER GROUP TMP UPPER WORK

    if (( "${#CRASHArr[@]}" > 0 )); then
      ediag "${BLD}Deleting ${#CRASHArr[*]} crashrecovery dir(s) for sync target ${BLU}${DIR?}${NRM}"
      local backup
      for backup in "${CRASHArr[@]}"; do
        ediag "${BLD}${RED} ${backup}${NRM}"
        debug "removing ${backup}"
        rm -rf "$backup"
      done
    else
      ediag "${BLD}Found no crashrecovery dirs for: ${BLU}${DIR?}${NRM}${BLD}${NRM}"
    fi

    diag
  }

  for_each_dir_with_crasharr _cleanup
}

enforce() {
  debug "\n${BLU}Enforcing number of backups${NRM}"

  _enforce() {
    debug_vars DIR BACKUP

    if (( "${#CRASHArr[@]}" > BACKUP_LIMIT_FINAL )); then
      debug "The backups are greater than ${BACKUP_LIMIT_FINAL}"
      local remove
      for remove in "${CRASHArr[@]:$BACKUP_LIMIT_FINAL}"; do
        debug "removing ${remove}"
        rm -rf "$remove"
      done
    else
      debug "The backups are less than ${BACKUP_LIMIT_FINAL}, nothing to do"
    fi
  }

  for_each_dir_with_crasharr _enforce
}

do_sync() {
  debug "\n${GRN}Syncing files${NRM}"

  # sync to tmpfs and back again
  _do_sync() {
    debug_vars DIR USER GROUP BACKUP TMP UPPER WORK

    # make tmpfs container
    if [[ -d "$DIR" ]]; then
      # retain permissions on sync target
      PREFIXP="$(stat -c %a "$DIR" 2>/dev/null)" || :
      PREFIXP="${PREFIXP:-0750}"

      if ! [[ -r "$TMP" ]]; then
        verbosely install -dm"$PREFIXP" --owner="${USER?}" --group="${GROUP?}" "$TMP" || return
      fi

      if ! [[ -r "$BACKUP" ]]; then
        verbosely install -dm"$PREFIXP" --owner="$USER" --group="$GROUP" "$BACKUP" || return
      fi

      if use_overlayfs; then
        debug "ensuring overlay directories"

        if ! [[ -r "$UPPER" ]]; then
          verbosely install -dm"$PREFIXP" --owner="$USER" --group="$GROUP" "$UPPER" || return
        fi

        if [[ "$OVERLAYFS_VERS" = 23 ]]; then
          if ! [[ -r "$WORK" ]]; then
            verbosely install -dm"$PREFIXP" --owner="$USER" --group="$GROUP" "$WORK" || return
          fi
        fi
      fi

      # sync the tmpfs targets to the disc
      if [[ -e "$TMP"/.flagged ]]; then
        debug "Syncing ${TMP} and ${BACKUP}"
        # don't do inplace sync
        set -x
        rsync -aX --delete-after --exclude .flagged "$TMP/" "$BACKUP/" --info=progress2 || return
        set +x
      else
        # backup target and link to tmpfs container
        ON_START="Bind mounting ${DIR} -> ${BACKUP}" verbosely run_mount_helper -s "$DIR" -d "$BACKUP" mountupbind || return

        if use_backups;then
          debug "Creating new linked backup directory ${BACK_OLD}"
          tempfile=$(mktemp)

          set -x
          # this copies all the files
          find "$BACKUP" -type l -printf '%P\n' > "$tempfile"
          rm -rf "$BACK_OLD"
          rsync -aX --no-links --link-dest="$DIR" "$DIR/" "$BACK_OLD/" --info=progress2 || return

          # this is used to handle the symlinks
          rsync -aXl --files-from="$tempfile" "$DIR/" "$BACK_OLD/" --info=progress2 || return

          set +x
          rm "$tempfile"
        fi

        # initial sync
        if use_overlayfs; then
          ON_START="Mounting overlay directory" verbosely run_mount_helper -v "$OVERLAYFS_VERS" -l "$BACKUP" -u "$UPPER" -w "$WORK" -d "$TMP" mountup || return
        else
          debug "Doing initial sync with ${BACKUP} and ${TMP}"
          set -x
          rsync -aXl --append "${BACKUP}/" "${TMP}/" --info=progress2 || return
          set +x
        fi

        ON_START="bind mounting ${TMP} -> ${DIR}" verbosely run_mount_helper -s "$TMP" -d "$DIR" mountupbind || return

        touch "${TMP}/.flagged" || return
      fi
    fi
  }

  for_each_dir _do_sync || {
    local rc="$?"
    ediag "${RED}Sync failed${NRM}"
    return "$rc"
  }

  ediag "${BLD}Sync successful${NRM}"

  ON_START="creating ${DAEMON_FILE}" verbosely touch "$DAEMON_FILE"
}

do_unsync() {
  debug "\n${RED}Unsyncing files${NRM}"

  _do_unsync() {
    debug_vars DIR USER GROUP TMP UPPER WORK

    # remove link and move data from tmpfs to disk
    if mountpoint -q "$DIR"; then
      # this assumes that the backup is always
      # updated so be sure to invoke a sync before an unsync
      ON_START="unmounting ${DIR}" verbosely run_mount_helper -d "$DIR" mountdownallforce || return

      ON_START="unmounting ${BACKUP}" verbosely run_mount_helper -d "$BACKUP" mountdownallforce || return

      debug "removing ${BACKUP}"
      rm -rf "$BACKUP"

      if use_overlayfs; then
        if mountpoint -q "$TMP"; then
          ON_START="unmounting $TMP" verbosely run_mount_helper -d "$TMP" mountdownlazy || return

          debug "removing overlayfs folders"
          rm -rf "$TMP" "$UPPER" "$WORK"
        fi
      elif [[ -d "$TMP" ]]; then
        debug "removing $TMP"
        rm -rf "$TMP"
      fi

      if use_backups; then
        debug "removing $BACK_OLD"
        rm -rf "$BACK_OLD"
      fi
    fi
  }

  local rc=0
  for_each_dir _do_unsync || rc="$?"

  if (( rc == 0 )); then
    ediag "${BLD}Unsync successful${NRM}"
  else
    ediag "${RED}Unsync failed${NRM}"
  fi

  # delete daemon file in the end, so that unsync can be run again
  # incase of some failure midway
  # since unsync also requires sync before, if any of the DIRS are unsynced during last run,
  # they will be synced again before unsyncing not leading to any breakage

  debug "Removing ${DAEMON_FILE} and ${ASDCONF_SNAPSHOT}"
  rm -f "$DAEMON_FILE" "$ASDCONF_SNAPSHOT"

  return "$rc"
}

parse() {
  if looks_like_systemd; then
    # running systemd
    asd_state="$(run_systemctl show -p ActiveState --value asd 2>/dev/null)" || :
    resync_state="$(run_systemctl show -p ActiveState --value asd-resync.timer 2>/dev/null)" || :

    if [[ "$asd_state" = "active" ]]; then
      asd_color="$GRN"
    else
      asd_color="$RED"
    fi

    if [[ "$resync_state" = "active" ]]; then
      resync_color="$GRN"
    else
      resync_color="$RED"
    fi

    ediag " ${BLD}Systemd service is currently ${asd_color}${asd_state}${NRM}${BLD}.${NRM}"
    ediag " ${BLD}Systemd resync service is currently ${resync_color}${resync_state}${NRM}${BLD}.${NRM}"
  else
    # using other init system + cron job for resync
    if [[ -x /etc/cron.hourly/asd-update ]]; then
      resync_state="present"
      resync_color="$GRN"
    else
      resync_state="not present"
      resync_color="$RED"
    fi

    ediag -n " ${BLD}Daemon pid file is "
    if [[ -f $DAEMON_FILE ]]; then
      ediag "${GRN}present${NRM}${BLD}.${NRM}"
    else
      ediag "${RED}not present${NRM}${BLD}.${NRM}"
    fi

    ediag " ${BLD}Resync cronjob is ${resync_color}${resync_state}${NRM}${BLD}.${NRM}"
  fi

  if use_overlayfs; then
    ediag "${BLD} OverlayFS v${OVERLAYFS_VERS} is currently ${GRN}active${NRM}${BLD}.${NRM}"
  else
    ediag "${BLD} OverlayFS technology is currently ${RED}inactive${NRM}${BLD}.${NRM}"
  fi

  diag
  ediag "${BLD}Anything-sync-daemon will manage the following per ${BLU}${ASDCONF}${NRM}${BLD} settings:${NRM}"
  diag

  _parse() {
    # sync target dir size
    if [[ -d "$DIR" ]]; then
      local justify
      justify="$(tput cr)$(tput cuf 20) "
      ediag " ${BLD}owner/group id:${justify}${USER}/${GROUP}${NRM}"
      ediag " ${BLD}target to manage:${justify}${GRN}${DIR}${NRM}"
      ediag " ${BLD}sync target:${justify}${BLU}${BACKUP}${NRM}"
      ediag " ${BLD}tmpfs target:${justify}${RED}${TMP}${NRM}"
      psize="$(du -Dh --max-depth=0 "$DIR" 2>/dev/null | awk '{ print $1 }')" || :
      ediag " ${BLD}dir size:${justify}${psize:-unknown}${NRM}"

      if use_overlayfs; then
        rwsize=$(du -Dh --max-depth=0 "$UPPER" 2>/dev/null | awk '{ print $1 }')
        ediag " ${BLD}overlayfs size:${justify}${rwsize}${NRM}"
      fi

      ediag -n " ${BLD}recovery dirs:"

      if (( "${#CRASHArr[@]}" ==  0 )); then
        ediag "${justify}none${NRM}"
      else
        ediag "${justify}${RED}${#CRASHArr[@]}${NRM}${BLD} <- delete with the c option${NRM}"
        for backup in "${CRASHArr[@]}"; do
          psize=$(du -Dh --max-depth=0 "$backup" 2>/dev/null | awk '{ print $1 }')
          ediag " ${BLD} dir path/size:${justify}${BLU}${backup} ${NRM}${BLD}(${psize})${NRM}"
        done
      fi

      diag
    fi
  }

  for_each_dir_with_crasharr _parse
}

configure_debugging() {
  if is_truthy "${DEBUG:-}"; then
    debug() {
      ediag "$@"
    }
  else
    debug() {
      :
    }
  fi
}

setup_early() {
  declare -gr PS4='+ ${BASH_SOURCE:-${0}}@${LINENO:-0}${FUNCNAME:+#${FUNCNAME}()}: '

  set -euo pipefail

  trap 'diag_error "$LINENO"' ERR

  configure_debugging

  debug "checking flock"
  have_dep_diag flock || return
  debug "flock found"

  if running_as_root; then
    run_systemctl() {
      run_systemctl_system "$@"
    }

    looks_like_systemd() {
      looks_like_systemd_system
    }

    if looks_like_systemd; then
      ASDCONFDIR="${ASDCONFDIR:-"${CONFIGURATION_DIRECTORY:-/etc/asd}"}"
      ASDRUNDIR="${ASDRUNDIR:-"${RUNTIME_DIRECTORY:-/run/asd}"}"
    else
      ASDCONFDIR="${ASDCONFDIR:-/etc/asd}"
      ASDRUNDIR="${ASDRUNDIR:-/run/asd}"
    fi
  else
    run_systemctl() {
      run_systemctl_user "$@"
    }

    looks_like_systemd() {
      looks_like_systemd_user
    }

    if looks_like_systemd; then
      ASDCONFDIR="${ASDCONFDIR:-"${CONFIGURATION_DIRECTORY:-${XDG_CONFIG_HOME:-${HOME?}/.config}/asd}"}"
      ASDRUNDIR="${ASDRUNDIR:-"${RUNTIME_DIRECTORY:-${XDG_RUNTIME_DIR:-/run/user/${EUID:-$(id -u)}}/asd}"}"
    else
      ASDCONFDIR="${ASDCONFDIR:-"${XDG_CONFIG_HOME:-${HOME?}/.config}/asd"}"
      ASDRUNDIR="${ASDRUNDIR:-"${XDG_RUNTIME_DIR:-/run/user/${EUID:-$(id -u)}}/asd"}"
    fi
  fi

  local root_path_trust_me=//././//./
  if have_dep realpath && [[ "$(realpath -m "$root_path_trust_me" 2>/dev/null)" = / ]]; then
    clean_path() {
      realpath -m "${1?}"
    }
  elif have_dep readlink && [[ "$(readlink -m "$root_path_trust_me" 2>/dev/null)" = / ]]; then
    clean_path() {
      readlink -m "${1?}"
    }
  else
    # Mind the parentheses!  This function runs in a subshell to avoid
    # clobbering the `extglob` setting in the "parent" shell.
    clean_path() (
      # ensuring pattern matching is enabled
      shopt -s extglob
      printf -- '%s' "${1%%+(/)}"
    )
  fi

  if [[ -n "${NO_COLOR:-}" ]]; then
    BLD=''
    RED=''
    GRN=''
    BLU=''
    NRM=''
  else
    BLD="\e[01m"
    RED="\e[01;31m"
    GRN="\e[01;32m"
    BLU="\e[01;34m"
    NRM="\e[00m"
  fi

  declare -gr BLD RED GRN BLU NRM

  declare -gr VERS='@VERSION@'

  declare -gr CRASH_RECOVERY_SUFFIX=crashrecovery
  declare -gr ASDCONFTIMEOUT="${ASDCONFTIMEOUT:-10}"

  ASDNAME=asd

  umask 027

  if use_v1_paths; then
    ASDCONF="${ASDCONF:-/etc/asd.conf}"
    DAEMON_FILE="${DAEMON_FILE:-/run/asd}"

    if [[ "$ASDCONF" != /etc/asd.conf ]]; then
      suffix="$(realpath "$ASDCONF" | sha256sum | cut -b -16)"
      ASDNAME="${ASDNAME}-${suffix}"
      if [[ "$DAEMON_FILE" == /run/asd ]]; then
        DAEMON_FILE="/run/${ASDNAME}"
      fi
    fi

    LOCKFILE="/run/${ASDNAME}-lock"
  else
    ASDCONF="${ASDCONF:-${ASDCONFDIR}/asd.conf}"
    DAEMON_FILE="${DAEMON_FILE:-${ASDRUNDIR}/asd.run}"
    LOCKFILE="${ASDRUNDIR}/asd.lock"

    mkdir -p "$ASDRUNDIR"
  fi

  declare -gr ASDCONFDIR ASDNAME ASDRUNDIR DAEMON_FILE LOCKFILE

  declare -gr ASDCONF_SOURCE="$ASDCONF"
  declare -gr ASDCONF_SNAPSHOT="${DAEMON_FILE}.conf"

  mkdir -p "$(dirname "$DAEMON_FILE")"
  mkdir -p "$(dirname "$LOCKFILE")"
}

setup_late() {
  debug "${RED}ASDNAME:${NRM} ${ASDNAME}"
  debug "${BLU}Configuration file:${NRM} ${ASDCONF_SOURCE}"
  debug "${GRN}Daemon file:${NRM} ${DAEMON_FILE}"
  debug "${RED}Lockfile:${NRM} ${LOCKFILE}\n"

  local systemd_unit_name
  if systemd_unit_name="$(systemd_unit_name 2>/dev/null)" && [[ -n "$systemd_unit_name" ]]; then
    debug "${BLU}Systemd unit name:${NRM} ${systemd_unit_name}"
  fi

  # Setup check /etc/asd.conf
  debug "Checking for existence of ${ASDCONF_SOURCE}"
  if [[ -f "$ASDCONF_SOURCE" ]]; then
    debug "Checking if asd is already running"

    if [[ -f "$DAEMON_FILE" ]]; then
      debug "Daemon file found; asd is running"
    else
      debug "Daemon file not found; asd is not running"
    fi
  else
    ediag " ${BLD}Cannot find ${ASDCONF_SOURCE} so bailing.${NRM}"
    ediag " ${BLD}Reinstall package to use anything-sync-daemon.${NRM}"
    return 1
  fi

  # if asd is active, source the snapshot of /etc/asd.conf preferentially
  if [[ -f "$ASDCONF_SNAPSHOT" ]]; then
    debug "\nRestoring old asd.conf configurations"
  else
    # make a snapshot of the current configuration on the tmpfs while asd is
    # running to keep any edits made to the live `ASDCONF` from potentially
    # orphaning the tmpfs copies thus preserving the data
    mkdir -p "$(dirname "$ASDCONF_SNAPSHOT")"
    ON_START="creating configuration snapshot at ${ASDCONF_SNAPSHOT}" \
      verbosely serialize_conf_vars_with_timeout "$ASDCONF_SOURCE" > "$ASDCONF_SNAPSHOT" || {
        rc="$?"
        ediag -n "${BLD}Error creating configuration snapshot ${ASDCONF_SNAPSHOT} from configuration file ${ASDCONF_SOURCE}"
        case "$rc" in
          # Probably timed out.  124 is coreutils, 143 is busybox.
          124|143)
            diag -n " (sourcing ${ASDCONF_SNAPSHOT} appears to have timed out)"
            ;;
        esac
        ediag "; cannot continue.${NRM}"
        rm -f "$ASDCONF_SNAPSHOT"
        return "$rc"
      }
  fi

  readonly ASDCONF="$ASDCONF_SNAPSHOT"

  # shellcheck source=./asd.conf source-path=SCRIPTDIR
  source "$ASDCONF" || {
    rc="$?"
    ediag "${BLD}Error sourcing ${ASDCONF}; cannot continue.${NRM}"
    rm -f "$ASDCONF_SNAPSHOT"
    return "$rc"
  }

  debug # just for an additional enter

  # Redeclare `debug`; configuration file may have altered `DEBUG` definition
  configure_debugging

  BACKUP_LIMIT_FINAL="${BACKUP_LIMIT:-5}"
  # define default number of crash-recovery snapshots to save if the user did not
  # and check that it is an integer if user did define it
  if ! [[ "$BACKUP_LIMIT_FINAL" =~ ^[[:digit:]]+$ ]]; then
    ediag " ${RED}ERROR:${NRM}${BLD} Bad value for BACKUP_LIMIT detected!${NRM}"
    return 1
  fi
  debug "Backup limit: ${BACKUP_LIMIT_FINAL}"

  # removing any trailing slash(es) from the list of directories to sync
  declare -gA WHATTOSYNC_MAP=()
  if [[ -v WHATTOSYNC ]]; then
    local whattosync_entry
    local -i whattosync_entry_count
    for whattosync_entry in "${WHATTOSYNC[@]}"; do
      whattosync_entry="$(clean_path "$whattosync_entry")"
      whattosync_entry_count="${WHATTOSYNC_MAP["$whattosync_entry"]:-0}"
      WHATTOSYNC_MAP["$whattosync_entry"]="$(( whattosync_entry_count + 1 ))"
    done
  fi

  VOLATILE_FINAL="${VOLATILE:-}"
  if [[ -z "${VOLATILE_FINAL:-}" ]]; then
    if use_v1_paths; then
      VOLATILE_FINAL=/tmp
    else
      VOLATILE_FINAL="$ASDRUNDIR"
    fi
  fi

  # clean up the volatile directory name (no trailing slashes, etc.)
  VOLATILE_FINAL="$(clean_path "$VOLATILE_FINAL")"

  debug "Volatile dir: ${VOLATILE_FINAL}"

  # bail if $VOLATILE isn't tmpfs
  looks_like_tmpfs_or_zram_diag "$VOLATILE_FINAL"

  if is_truthy "${ENABLE_HARDLINK_SAFETY_CHECK:-1}"; then
    debug "Hardlink safety check: yes"

    enable_hardlink_safety_check() {
      return 0
    }
  else
    debug "Hardlink safety check: no"

    enable_hardlink_safety_check() {
      return 1
    }
  fi


  # simple function to determine user intent rather than using a null value
  if is_truthy "${USE_OVERLAYFS:-0}"; then
    use_overlayfs() {
      return 0
    }
  else
    use_overlayfs() {
      return 1
    }
  fi

  # since the default for this one is a yes, need to force a null value to yes
  if is_truthy "${USE_BACKUPS:-1}"; then
    debug "Backups enabled: yes"

    use_backups() {
      return 0
    }
  else
    debug "Backups enabled: no"

    use_backups() {
      return 1
    }
  fi

  # determine is we are using overlayfs (v22 and below) or overlay (v23 and above)
  # overlay FS v23 and later requires both an upper and a work directory, both on
  # the same filesystem, but not part of the same subtree.
  #
  # ubuntu 15.04 has both overlay and overlayfs so prefer version 23
  if use_overlayfs; then
    # first test if either module is manually loaded manually or hardcoded
    if grep -qiE "overlay$" /proc/filesystems 2>/dev/null; then
      OVERLAYFS_VERS=23
    elif grep -qiE "overlayfs$" /proc/filesystems 2>/dev/null; then
      OVERLAYFS_VERS=22
    # since mount should call modprobe on invocation, check to see if either
    # module is in the tree using modinfo
    elif modinfo overlay &>/dev/null; then
      OVERLAYFS_VERS=23
    elif modinfo overlayfs &>/dev/null; then
      OVERLAYFS_VERS=22
    else
      diag "overlayfs is not supported by your system, falling back to normal."

      use_overlayfs() {
        return 1
      }
    fi
  fi

  if use_overlayfs; then
    debug "overlayfs enabled: yes"
  else
    debug "overlayfs enabled: no"
  fi

  debug "overlayfs version: ${OVERLAYFS_VERS:-unknown}"

  # get distro name
  # first try os-release
  if [[ -f /etc/os-release ]]; then
    # shellcheck source=/dev/null
    source /etc/os-release 2>/dev/null || :
    DISTRO="${PRETTY_NAME:-${NAME}}"
  fi

  # if not os-release try issue
  DISTRO="${DISTRO:-$(sed -n '/./ { s| \\.*$||; p; q }' /etc/issue 2>/dev/null)}" || :

  if [[ -z "$DISTRO" ]]; then
    header() {
      ediag "${BLD}Anything-sync-daemon v${VERS}${NRM}"
      diag
    }
  else
    header() {
      ediag "${BLD}Anything-sync-daemon v${VERS}${NRM}${BLD} on ${DISTRO:-unknown distribution}${NRM}"
      diag
    }
  fi

  if need_sudo_to_mount; then
    run_mount_helper() {
      sudo asd-mount-helper "$@"
    }
  else
    run_mount_helper() {
      asd-mount-helper "$@"
    }
  fi

  # Re-declare these globally, forbidding further modification.
  declare -gr \
    DISTRO="$DISTRO" \
    OVERLAYFS_VERS="${OVERLAYFS_VERS:-}" \
    BACKUP_LIMIT_FINAL="$BACKUP_LIMIT_FINAL"  \
    VOLATILE_FINAL="$VOLATILE_FINAL"

  declare -r WHATTOSYNC_MAP
}

main() {
  setup_early || return

  exec {flock_fd}>>"$LOCKFILE" || {
    croak "failed to open lockfile ${LOCKFILE}"
    return
  }

  flock -x -n "$flock_fd" || {
    croak "failed to obtain exclusive lock on lockfile ${LOCKFILE}"
    return
  }

  setup_late || return

  case "${1:-}" in
    p|P|Parse|parse|Preview|preview|debug)
      header
      dep_check
      config_check
      parse
      ;;
    c|C|clean|Clean)
      header
      dep_check
      config_check
      cleanup
      ;;
    sync)
      if ! [[ -f "$DAEMON_FILE" ]]; then
        dep_check
        config_check
        ungraceful_state_check
        do_sync
        enforce
      else
        ediag "${GRN}ASD is already running${NRM}"
      fi
      ;;
    resync)
      if [[ -f "$DAEMON_FILE" ]]; then
        ungraceful_state_check
        do_sync
      else
        ediag "${RED}ASD is not running${NRM}"
      fi
      ;;
    unsync)
      # make sure the daemon ran to setup the links
      if [[ -f "$DAEMON_FILE" ]]; then
        ungraceful_state_check
        do_sync
        do_unsync
      else
        ediag "${RED}ASD is not running${NRM}"
      fi
      ;;
    *)
      echo -e "${BLD}Anything-sync-daemon v${VERS}${NRM}"
      echo
      echo -e " ${BLD}${0} ${NRM}${GRN}[option]${NRM}"
      echo -e " ${BLD} ${NRM}${GRN}preview${NRM}${BLD}  Parse config file (${NRM}${BLU}${ASDCONF}${NRM}${BLD}) to see what will be managed.${NRM}"
      echo -e " ${BLD} ${NRM}${GRN}clean${NRM}${BLD}		Clean (delete without prompting) ALL crashrecovery dirs.${NRM}"
      echo -e " ${BLD} ${NRM}${GRN}resync${NRM}${BLD} Synchronize the tmpfs and media bound copy. Must be run as root user.${NRM}"
      echo -e " ${BLD} ${NRM}${RED}sync${NRM}${BLD}   Force a manual sync. NOT recommended.${NRM}"
      echo -e " ${BLD} ${NRM}${RED}unsync${NRM}${BLD} Force a manual unsync. NOT recommended.${NRM}"
      echo
      echo -e " ${BLD}It is ${RED}HIGHLY DISCOURAGED${NRM}${BLD} to directly call ${0} to sync or to unsync.${NRM}"
      if looks_like_systemd; then
        echo -e " ${BLD}Instead, use systemd to start/stop anything-sync-daemon.${NRM}"
        echo
        echo -e " ${BLD}systemctl ${NRM}${GRN}[option]${NRM}${BLD} asd asd-resync${NRM}"
        echo -e " ${BLD} ${NRM}${GRN}start${NRM}${BLD}    Turn on daemon; make symlinks and actively manage targets in tmpfs.${NRM}"
        echo -e " ${BLD} ${NRM}${GRN}stop${NRM}${BLD}   Turn off daemon; remove symlinks and rotate tmpfs data back to disc.${NRM}"
        echo -e " ${BLD} ${NRM}${GRN}enable${NRM}${BLD} Autostart daemon when system comes up.${NRM}"
        echo -e " ${BLD} ${NRM}${GRN}disable${NRM}${BLD}  Remove daemon from the list of autostart daemons.${NRM}"
      elif [[ -f /etc/init.d/asd ]]; then
        echo -e " ${BLD}Instead, use the init system to start/stop anything-sync-daemon.${NRM}"
        echo
        echo -e " ${BLD}sudo service asd ${NRM}${GRN}[option]${NRM}${BLD} or /etc/init.d/asd ${NRM}${GRN}[option]${NRM}"
        echo -e " ${BLD} ${NRM}${GRN}start${NRM}${BLD}  Turn on daemon; make symlinks and actively manage targets in tmpfs.${NRM}"
        echo -e " ${BLD} ${NRM}${GRN}stop${NRM}${BLD} Turn off daemon; remove symlinks and rotate tmpfs data back to disc.${NRM}"
      fi
      ;;
  esac
}

# Being executed, not sourced.
if ! (return 0) &>/dev/null; then
  main "$@"
fi

# vim:set ts=2 sw=2 et:
